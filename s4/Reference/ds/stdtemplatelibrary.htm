<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./StdTemplateLibrary_files/filelist.xml">
<title>Standard Template Library</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>MANJU_P</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>Administrator</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>32</o:TotalTime>
  <o:Created>2007-05-17T05:49:00Z</o:Created>
  <o:LastSaved>2007-05-17T05:49:00Z</o:LastSaved>
  <o:Pages>8</o:Pages>
  <o:Words>3479</o:Words>
  <o:Characters>19834</o:Characters>
  <o:Lines>165</o:Lines>
  <o:Paragraphs>39</o:Paragraphs>
  <o:CharactersWithSpaces>24357</o:CharactersWithSpaces>
  <o:Version>9.3821</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:PunctuationKerning/>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:"Lucida Console";
	panose-1:2 11 6 9 4 5 4 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:modern;
	mso-font-pitch:fixed;
	mso-font-signature:-2147482993 6144 0 0 31 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:windowtext;}
h1
	{margin-right:0in;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:1;
	font-size:24.0pt;
	font-family:"Times New Roman";
	color:black;
	mso-font-kerning:18.0pt;
	font-weight:bold;}
h2
	{margin-right:0in;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:2;
	font-size:18.0pt;
	font-family:"Times New Roman";
	color:black;
	font-weight:bold;}
h3
	{margin-right:0in;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:3;
	font-size:13.5pt;
	font-family:"Times New Roman";
	color:windowtext;
	font-weight:bold;}
h4
	{margin-right:0in;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:4;
	font-size:12.0pt;
	font-family:"Times New Roman";
	color:windowtext;
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:#006600;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p
	{margin-right:0in;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
code
	{mso-ascii-font-family:"Lucida Console";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Lucida Console";
	mso-bidi-font-family:"Courier New";
	mso-hide:none;
	font-style:normal;
	vertical-align:baseline;
	vertical-align:baseline;}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
tt
	{mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US link="#006600" vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<h1 align=center style='text-align:center'><span style='font-size:20.0pt'>Standard
Template Library<o:p></o:p></span></h1>

<p style='text-align:justify'>The Standard Template Library, or STL, is a C++
library of container classes, algorithms, and iterators; it provides many of
the basic algorithms and data structures of computer science. The STL is a
generic library, meaning that its components are heavily parameterized: almost
every component in the STL is a template. </p>

<h2>Containers and algorithms</h2>

<p style='text-align:justify'>Like many class libraries, the STL includes <span
style='mso-bidi-font-style:italic'>container</span> classes: classes whose
purpose is to contain other objects. The STL includes the classes <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/Vector.html"><span
style='color:black;text-decoration:none;text-underline:none'>vector</span></a></span></tt>,
<tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><a
href="http://www.sgi.com/tech/stl/List.html"><span style='color:black;
text-decoration:none;text-underline:none'>list</span></a></span></tt>, <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/Deque.html"><span
style='color:black;text-decoration:none;text-underline:none'>deque</span></a></span></tt>,
<tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><a
href="http://www.sgi.com/tech/stl/set.html"><span style='color:black;
text-decoration:none;text-underline:none'>set</span></a></span></tt>, <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/multiset.html"><span
style='color:black;text-decoration:none;text-underline:none'>multiset</span></a></span></tt>,
<tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><a
href="http://www.sgi.com/tech/stl/Map.html"><span style='color:black;
text-decoration:none;text-underline:none'>map</span></a></span></tt>, <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/Multimap.html"><span
style='color:black;text-decoration:none;text-underline:none'>multimap</span></a></span></tt>,
<tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><a
href="http://www.sgi.com/tech/stl/hash_set.html"><span style='color:black;
text-decoration:none;text-underline:none'>hash_set</span></a></span></tt>, <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/hash_multiset.html"><span
style='color:black;text-decoration:none;text-underline:none'>hash_multiset</span></a></span></tt>,
<tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><a
href="http://www.sgi.com/tech/stl/hash_map.html"><span style='color:black;
text-decoration:none;text-underline:none'>hash_map</span></a></span></tt>, and <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/hash_multimap.html"><span
style='color:black;text-decoration:none;text-underline:none'>hash_multimap</span></a></span></tt>.
Each of these classes is a template, and can be instantiated to contain any
type of object. You can, for example, use a <tt><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>vector&lt;int&gt;</span></tt>
in much the same way as you would use an ordinary C array, except that <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></tt> eliminates the chore of managing dynamic
memory allocation by hand.</p>

<pre><span style='font-size:12.0pt;font-family:"Times New Roman"'><span style="mso-spacerun: yes">      </span>vector&lt;int&gt; v(3);<span style="mso-spacerun: yes">            </span>// Declare a vector of 3 elements.<o:p></o:p></span></pre><pre><span
style='font-size:12.0pt;font-family:"Times New Roman"'><span style="mso-spacerun: yes">      </span>v[0] = 7;<o:p></o:p></span></pre><pre><span
style='font-size:12.0pt;font-family:"Times New Roman"'><span style="mso-spacerun: yes">      </span>v[1] = v[0] + 3;<o:p></o:p></span></pre><pre><span
style='font-size:12.0pt;font-family:"Times New Roman"'><span style="mso-spacerun: yes">      </span>v[2] = v[0] + v[1];<span style="mso-spacerun: yes">          </span>// v[0] == 7, v[1] == 10, v[2] == 17<span style="mso-spacerun: yes">  </span><o:p></o:p></span></pre>

<p style='text-align:justify'>The STL also includes a large collection of <span
style='mso-bidi-font-style:italic'>algorithms</span> that manipulate the data stored
in containers. You can reverse the order of elements in a <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></tt>, for example, by using the <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/reverse.html"><span
style='color:black;text-decoration:none;text-underline:none'>reverse</span></a></span></tt>
algorithm. </p>

<pre><span style='font-size:12.0pt;font-family:"Times New Roman"'><span style="mso-spacerun: yes">      </span>reverse(v.begin(), v.end()); // v[0] == 17, v[1] == 10, v[2] == 7<o:p></o:p></span></pre>

<p style='text-align:justify'>There are two important points to notice about
this call to <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>reverse</span></tt>. First, it is a
global function, not a member function. Second, it takes two arguments rather
than one: it operates on a <span style='mso-bidi-font-style:italic'>range</span>
of elements, rather than on a container. In this particular case the range
happens to be the entire container <tt><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>v.</span></tt></p>

<pre style='text-align:justify'><span style='font-size:12.0pt;font-family:"Times New Roman"'>The reason for both of these facts is the same: <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>reverse</span></tt>, like other STL algorithms, is decoupled from the STL container classes. This means that <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>reverse</span></tt> can be used not only to reverse elements in vectors, but also to reverse elements in lists, and even elements in C arrays. <o:p></o:p></span></pre>

<h2>Iterators</h2>

<p class=MsoNormal style='text-align:justify'><span style='color:black'>Iterators
are a generalization of pointers: they are objects that point to other objects.
As the name suggests, iterators are often used to iterate over a range of
objects: if an iterator points to one element in a range, then it is possible
to increment it so that it points to the next element. <o:p></o:p></span></p>

<p style='text-align:justify'>In the example of reversing a C array, the
arguments to <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>reverse</span></tt> are iterators,
which are a generalization of pointers. Pointers themselves are iterators,
which is why it is possible to reverse the elements of a C array. Similarly, <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></tt> declares the nested types <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>iterator</span></tt> and <tt><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>const_iterator</span></tt>.
There are also some iterators, such as <tt><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><a
href="http://www.sgi.com/tech/stl/istream_iterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>istream_iterator</span></a></span></tt>
and <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><a
href="http://www.sgi.com/tech/stl/ostream_iterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>ostream_iterator</span></a></span></tt>,
that aren't associated with containers at all. </p>

<p style='text-align:justify'>Iterators are the mechanism that makes it
possible to decouple algorithms from containers: algorithms are templates, and
are parameterized by the type of iterator, so they are not restricted to a
single type of container. Consider, for example, how to write an algorithm that
performs linear search through a range. This is the STL's <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/find.html"><span
style='color:black;text-decoration:none;text-underline:none'>find</span></a></span></tt>
algorithm. </p>

<pre style='text-align:justify'><span style='font-size:12.0pt;font-family:"Times New Roman"'><span style="mso-spacerun: yes">      </span>template &lt;class InputIterator, class T&gt;<o:p></o:p></span></pre><pre
style='text-align:justify'><span style='font-size:12.0pt;font-family:"Times New Roman"'><span style="mso-spacerun: yes">      </span>InputIterator find(InputIterator first, InputIterator last, const T&amp; value) {<o:p></o:p></span></pre><pre
style='text-align:justify'><span style='font-size:12.0pt;font-family:"Times New Roman"'><span style="mso-spacerun: yes">          </span>while (first != last &amp;&amp; *first != value) ++first;<o:p></o:p></span></pre><pre
style='text-align:justify'><span style='font-size:12.0pt;font-family:"Times New Roman"'><span style="mso-spacerun: yes">          </span>return first;<o:p></o:p></span></pre><pre
style='text-align:justify'><span style='font-size:12.0pt;font-family:"Times New Roman"'><span style="mso-spacerun: yes">      </span>}<o:p></o:p></span></pre>

<p style='text-align:justify'><tt><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>Find</span></tt>
takes three arguments: two iterators that define a range, and a value to search
for in that range. It examines each iterator in the range <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>[first, last)</span></tt>, proceeding from the beginning to
the end, and stops either when it finds an iterator that points to <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>value</span></tt> or when it reaches the end of the range. </p>

<pre style='text-align:justify'><tt><span style='font-size:12.0pt;font-family:
"Times New Roman"'>First</span></tt><span style='font-size:12.0pt;font-family:
"Times New Roman"'> and <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>last</span></tt> are declared to be of type <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>InputIterator</span></tt>, and <tt><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>InputIterator</span></tt> is a template parameter. That is, there isn't actually any type called <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>InputIterator</span></tt>: when you call <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>find</span></tt>, the compiler substitutes the actual type of the arguments for the formal type parameters <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>InputIterator</span></tt> and <tt><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>T</span></tt>. If the first two arguments to <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>find</span></tt> are of type <tt><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>int*</span></tt> and the third is of type <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>int.<o:p></o:p></span></tt></span></pre><pre
style='text-align:justify'><tt><span style='font-size:12.0pt;font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></tt></pre>

<p style='text-align:justify'>Iterators are central to generic programming
because they are an interface between containers and algorithms: algorithms
typically take iterators as arguments, so a container need only provide a way
to access its elements using iterators. This makes it possible to write a
generic algorithm that operates on many different kinds of containers, even
containers as different as a <a href="http://www.sgi.com/tech/stl/Vector.html"><span
style='color:black;text-decoration:none;text-underline:none'>vector</span></a>
and a <a href="http://www.sgi.com/tech/stl/List.html"><span style='color:black;
text-decoration:none;text-underline:none'>doubly linked list</span></a>. </p>

<p style='text-align:justify'>The STL defines several different concepts
related to iterators, several predefined iterators, and a collection of types
and functions for manipulating iterators. </p>

<h3><span style='font-size:14.0pt;mso-bidi-font-size:13.5pt'>Description<o:p></o:p></span></h3>

<p class=MsoNormal style='text-align:justify'><span style='color:black'>Iterators
are in fact not a single concept, but six concepts that form a hierarchy: some
of them define only a very restricted set of operations, while others define
additional functionality. The five concepts that are actually used by
algorithms are <a href="http://www.sgi.com/tech/stl/InputIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Input Iterator</span></a>,
<a href="http://www.sgi.com/tech/stl/OutputIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Output Iterator</span></a>,
<a href="http://www.sgi.com/tech/stl/ForwardIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Forward Iterator</span></a>,
<a href="http://www.sgi.com/tech/stl/BidirectionalIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Bidirectional
Iterator</span></a>, and <a
href="http://www.sgi.com/tech/stl/RandomAccessIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Random Access
Iterator</span></a>. A sixth concept, <a
href="http://www.sgi.com/tech/stl/trivial.html"><span style='color:black;
text-decoration:none;text-underline:none'>Trivial Iterator</span></a>, is
introduced only to clarify the definitions of the other iterator concepts. <o:p></o:p></span></p>

<p style='text-align:justify'>The most restricted sorts of iterators are <a
href="http://www.sgi.com/tech/stl/InputIterator.html"><span style='color:black;
text-decoration:none;text-underline:none'>Input Iterators</span></a> and <a
href="http://www.sgi.com/tech/stl/OutputIterator.html"><span style='color:black;
text-decoration:none;text-underline:none'>Output Iterators</span></a>, both of
which permit &quot;single pass&quot; algorithms but do not necessarily support
&quot;multi-pass&quot; algorithms. <a
href="http://www.sgi.com/tech/stl/InputIterator.html"><span style='color:black;
text-decoration:none;text-underline:none'>Input iterators</span></a> only
guarantee read access: it is possible to dereference an <a
href="http://www.sgi.com/tech/stl/InputIterator.html"><span style='color:black;
text-decoration:none;text-underline:none'>Input Iterator</span></a> to obtain
the value it points to, but not it is not necessarily possible to assign a new
value through an input iterator. Similarly, <a
href="http://www.sgi.com/tech/stl/OutputIterator.html"><span style='color:black;
text-decoration:none;text-underline:none'>Output Iterators</span></a> only
guarantee write access: it is possible to assign a value through an <a
href="http://www.sgi.com/tech/stl/OutputIterator.html"><span style='color:black;
text-decoration:none;text-underline:none'>Output Iterator</span></a>, but not
necessarily possible to refer to that value. </p>

<p style='text-align:justify'><a
href="http://www.sgi.com/tech/stl/ForwardIterator.html"><span style='color:
black;text-decoration:none;text-underline:none'>Forward Iterators</span></a>
are a refinement of <a href="http://www.sgi.com/tech/stl/InputIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Input Iterators</span></a>
and <a href="http://www.sgi.com/tech/stl/OutputIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Output Iterators</span></a>:
they support the <a href="http://www.sgi.com/tech/stl/InputIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Input Iterator</span></a>
and <a href="http://www.sgi.com/tech/stl/OutputIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Output Iterator</span></a>
operations and also provide additional functionality. In particular, it is
possible to use &quot;multi-pass&quot; algorithms with <a
href="http://www.sgi.com/tech/stl/ForwardIterator.html"><span style='color:
black;text-decoration:none;text-underline:none'>Forward Iterators</span></a>. A
<a href="http://www.sgi.com/tech/stl/ForwardIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Forward Iterator</span></a>
may be constant, in which case it is possible to access the object it points to
but not to to assign a new value through it, or mutable, in which case it is
possible to do both. </p>

<p style='text-align:justify'><a
href="http://www.sgi.com/tech/stl/BidirectionalIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Bidirectional
Iterators</span></a>, like <a
href="http://www.sgi.com/tech/stl/ForwardIterator.html"><span style='color:
black;text-decoration:none;text-underline:none'>Forward Iterators</span></a>,
allow multi-pass algorithms. As the name suggests, they are different in that
they support motion in both directions: a <a
href="http://www.sgi.com/tech/stl/BidirectionalIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Bidirectional
Iterator</span></a> may be incremented to obtain the next element or
decremented to obtain the previous element. A <a
href="http://www.sgi.com/tech/stl/ForwardIterator.html"><span style='color:
black;text-decoration:none;text-underline:none'>Forward Iterator</span></a>, by
contrast, is only required to support forward motion. An iterator used to
traverse a singly linked list, for example, would be a <a
href="http://www.sgi.com/tech/stl/ForwardIterator.html"><span style='color:
black;text-decoration:none;text-underline:none'>Forward Iterator</span></a>,
while an iterator used to traverse a doubly linked list would be a <a
href="http://www.sgi.com/tech/stl/BidirectionalIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Bidirectional
Iterator</span></a>. </p>

<p style='text-align:justify'>Finally, <a
href="http://www.sgi.com/tech/stl/RandomAccessIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Random Access
Iterators</span></a> allow the operations of pointer arithmetic: addition of
arbitrary offsets, subscripting, subtraction of one iterator from another to
find a distance, and so on. </p>

<p style='text-align:justify'>Most algorithms are expressed not in terms of a
single iterator but in terms of a range of iterators; the notation <tt><span
style='mso-ansi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>[first,
last)</span></tt> refers to all of the iterators from <tt><span
style='mso-ansi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>first</span></tt>
up to, but not including, <tt><span style='mso-ansi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>last</span></tt>. Note that a range may
be empty, i.e. <tt><span style='mso-ansi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>first</span></tt> and <tt><span style='mso-ansi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>last</span></tt> may be the same
iterator. Note also that if there are <tt><span style='mso-ansi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>n</span></tt> iterators in a range,
then the notation <tt><span style='mso-ansi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>[first, last)</span></tt> represents <tt><span
style='mso-ansi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>n+1</span></tt>
positions. This is crucial: algorithms that operate on <tt><span
style='mso-ansi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>n</span></tt>
things frequently require <tt><span style='mso-ansi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>n+1</span></tt> positions. Linear
search, for example must be able to return some value to indicate that the
search was unsuccessful. </p>

<p style='text-align:justify'>Sometimes it is important to be able to infer
some properties of an iterator: the type of object that is returned when it is
dereferenced, for example. There are two different mechanisms to support this
sort of inferrence: an older mechanism called <a
href="http://www.sgi.com/tech/stl/iterator_tags.html"><span style='color:black;
text-decoration:none;text-underline:none'>Iterator Tags</span></a>, and a newer
mechanism called <tt><span style='mso-ansi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/iterator_traits.html"><span
style='mso-fareast-font-family:"Courier New";color:black;text-decoration:none;
text-underline:none'>iterator_traits</span></a></span></tt>. </p>

<pre style='text-align:justify'><span style='font-size:12.0pt;font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></pre>

<h2><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></h2>

<h2>Concepts and Modeling</h2>

<p style='text-align:justify'>One very important question to ask about any
template function, not just about STL algorithms, is what the set of types is
that may correctly be substituted for the formal template parameters. Clearly,
for example, <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>int*</span></tt> or <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>double*</span></tt> may be substituted for <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>find</span></tt>'s formal template parameter <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>InputIterator</span></tt>. Equally clearly, <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>int</span></tt> or <tt><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>double</span></tt>
may not: <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>find</span></tt> uses the expression <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>*first</span></tt>, and the dereference operator makes no
sense for an object of type <tt><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>int</span></tt> or of
type <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>double</span></tt>. The basic answer,
then, is that <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>find</span></tt> implicitly defines a
set of requirements on types, and that it may be instantiated with any type
that satisfies those requirements. Whatever type is substituted for <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>InputIterator</span></tt> must provide certain operations:
it must be possible to compare two objects of that type for equality, it must
be possible to increment an object of that type, it must be possible to
dereference an object of that type to obtain the object that it points to, and
so on. </p>

<p style='text-align:justify'><tt><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>Find</span></tt>
isn't the only STL algorithm that has such a set of requirements; the arguments
to <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'><a
href="http://www.sgi.com/tech/stl/for_each.html"><span style='color:black;
text-decoration:none;text-underline:none'>for_each</span></a></span></tt> and <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/count.html"><span
style='color:black;text-decoration:none;text-underline:none'>count</span></a></span></tt>,
and other algorithms, must satisfy the same requirements. These requirements
are sufficiently important that we give them a name: we call such a set of type
requirements a <span style='mso-bidi-font-style:italic'>concept</span>, and we
call this particular concept <span style='mso-bidi-font-weight:bold'><a
href="http://www.sgi.com/tech/stl/InputIterator.html"><span style='color:black;
text-decoration:none;text-underline:none'>Input Iterator</span></a></span>. We
say that a type <span style='mso-bidi-font-style:italic'>conforms to a concept</span>,
or that it <span style='mso-bidi-font-style:italic'>is a model of a concept</span>,
if it satisfies all of those requirements. We say that <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>int*</span></tt> is a model of <span style='mso-bidi-font-weight:
bold'>Input Iterator</span> because <tt><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>int*</span></tt>
provides all of the operations that are specified by the <span
style='mso-bidi-font-weight:bold'>Input Iterator</span> requirements. </p>

<p style='text-align:justify'>Concepts are not a part of the C++ language;
there is no way to declare a concept in a program, or to declare that a
particular type is a model of a concept. Nevertheless, concepts are an
extremely important part of the STL. Using concepts makes it possible to write
programs that cleanly separate interface from implementation. </p>

<h2>Refinement</h2>

<p style='text-align:justify'><span style='mso-bidi-font-weight:bold'>Input
Iterator is, in fact, a rather weak concept: that is, it imposes very few
requirements. An Input Iterator must support a subset of pointer arithmetic (it
must be possible to increment an Input Iterator using prefix and postfix <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>operator++</span></tt>), but need not support all operations
of pointer arithmetic. This is sufficient for <tt><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'><a
href="http://www.sgi.com/tech/stl/find.html"><span style='color:black;
text-decoration:none;text-underline:none'>find</span></a></span></tt>, but some
other algorithms require that their arguments satisfy additional requirements. <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/reverse.html"><span
style='color:black;text-decoration:none;text-underline:none'>Reverse</span></a></span></tt>,
for example, must be able to decrement its arguments as well as increment them;
it uses the expression <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>--last</span></tt>. In terms of
concepts, we say that <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>reverse</span></tt>'s arguments must be
models of <a href="http://www.sgi.com/tech/stl/BidirectionalIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Bidirectional
Iterator</span></a> rather than Input Iterator. <o:p></o:p></span></p>

<p style='text-align:justify'><span style='mso-bidi-font-weight:bold'>The
Bidirectional Iterator concept is very similar to the Input Iterator concept:
it simply imposes some additional requirements. The types that are models of
Bidirectional Iterator are a subset of the types that are models of Input
Iterator: every type that is a model of Bidirectional Iterator is also a model
of Input Iterator. <tt><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>Int*</span></tt>, for example, is both
a model of Bidirectional Iterator and a model of Input Iterator, but <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'><a href="http://www.sgi.com/tech/stl/istream_iterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>istream_iterator</span></a></span></tt>,
is only a model of Input Iterator: it does not conform to the more stringent
Bidirectional Iterator requirements. <o:p></o:p></span></p>

<p style='text-align:justify'><span style='mso-bidi-font-weight:bold'>We
describe the relationship between Input Iterator and Bidirectional Iterator by
saying that Bidirectional Iterator is a refinement of Input Iterator.
Refinement of concepts is very much like inheritance of C++ classes; the main
reason we use a different word, instead of just calling it &quot;inheritance&quot;,
is to emphasize that refinement applies to concepts rather than to actual
types.<o:p></o:p></span></p>

<p style='text-align:justify'><span style='mso-bidi-font-weight:bold'>There are
actually three more iterator concepts in addition to the two that we have
already discussed: the five iterator concepts are <a
href="http://www.sgi.com/tech/stl/OutputIterator.html"><span style='color:black;
text-decoration:none;text-underline:none'>Output Iterator</span></a>, <a
href="http://www.sgi.com/tech/stl/InputIterator.html"><span style='color:black;
text-decoration:none;text-underline:none'>Input Iterator</span></a>, <a
href="http://www.sgi.com/tech/stl/ForwardIterator.html"><span style='color:
black;text-decoration:none;text-underline:none'>Forward Iterator</span></a>, <a
href="http://www.sgi.com/tech/stl/BidirectionalIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Bidirectional
Iterator</span></a>, and <a
href="http://www.sgi.com/tech/stl/RandomAccessIterator.html"><span
style='color:black;text-decoration:none;text-underline:none'>Random Access
Iterator</span></a>; Forward Iterator is a refinement of Input Iterator,
Bidirectional Iterator is a refinement of Forward Iterator, and Random Access
Iterator is a refinement of Bidirectional Iterator. (<a
href="http://www.sgi.com/tech/stl/OutputIterator.html"><span style='color:black;
text-decoration:none;text-underline:none'>Output Iterator</span></a> is related
to the other four concepts, but it is not part of the hierarchy of refinement:
it is not a refinement of any of the other iterator concepts, and none of the
other iterator concepts are refinements of it.) <o:p></o:p></span></p>

<h2>Other parts of the STL</h2>

<p style='text-align:justify'>If you understand algorithms, iterators, and
containers, then you understand almost everything there is to know about the
STL. The STL does, however, include several other types of components. </p>

<p style='text-align:justify'>First, the STL includes several utilities: very
basic concepts and functions that are used in many different parts of the
library. The concept <a href="http://www.sgi.com/tech/stl/Assignable.html"><span
style='color:black;text-decoration:none;text-underline:none'>Assignable</span></a>,
for example, describes types that have assignment operators and copy
constructors; almost all STL classes are models of Assignable, and almost all
STL algorithms require their arguments to be models of Assignable. </p>

<p style='text-align:justify'>Second, the STL includes some low-level
mechanisms for allocating and deallocating memory. <a
href="http://www.sgi.com/tech/stl/Allocators.html"><span style='color:black;
text-decoration:none;text-underline:none'>Allocators</span></a> are very
specialized, and you can safely ignore them for almost all purposes. </p>

<p style='text-align:justify'>Finally, the STL includes a large collection of <a
href="http://www.sgi.com/tech/stl/functors.html"><span style='color:black;
text-decoration:none;text-underline:none'>function objects</span></a>, also
known as functors. Just as iterators are a generalization of pointers, function
objects are a generalization of functions: a function object is anything that you
can call using the ordinary function call syntax. There are several different
concepts relating to function objects, including <a
href="http://www.sgi.com/tech/stl/UnaryFunction.html"><span style='color:black;
text-decoration:none;text-underline:none'>Unary Function</span></a> (a function
object that takes a single argument, i.e. one that is called as <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>f(x)</span></tt>) and <a
href="http://www.sgi.com/tech/stl/BinaryFunction.html"><span style='color:black;
text-decoration:none;text-underline:none'>Binary Function</span></a> (a
function object that takes two arguments, i.e. one that is called as <tt><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>f(x, y)</span></tt>). Function objects are an important part
of generic programming because they allow abstraction not only over the types
of objects, but also over the operations that are being performed. </p>

<h2><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></h2>

<h2><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></h2>

<h2>Sequence</h2>

<h3 style='text-align:justify'><span style='font-size:12.0pt;color:black;
font-weight:normal'>A Sequence is a variable-sized <a
href="http://www.sgi.com/tech/stl/Container.html"><span style='color:black'>Container</span></a>
whose elements are arranged in a strict linear order. It supports insertion and
removal of elements.</span>

<p><span style='font-size:12.0pt;color:black;font-weight:normal'><span
style="mso-spacerun: yes"> </span><o:p></o:p></span></p>

<h3 style='text-align:justify'><strong><span style='font-size:14.0pt;
color:black'>Sequence Containers</span></strong><span style='font-size:14.0pt;
color:black'><o:p></o:p></span></h3>

<p style='text-align:justify'><span style='font-weight:normal'>The C++ Standard
Template Library provides three sequence containers—<code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></code>, <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>list</span></code>
and <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>deque</span></code>. Class template <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></code> and class template <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>deque</span></code> both are based on arrays. Class template
<code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>list</span></code> implements a
linked-list data structure.</span></p>

<p style='text-align:justify'><span style='font-weight:normal'>One of the most
popular containers in the STL is <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>vector</span></code>.
A <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>vector</span></code> changes size
dynamically. Unlike C and C++ arrays, <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>vectors</span></code>
can be assigned to one another. This is not possible with pointer-based, C-like
arrays, because those array names are constant pointers and cannot be the
targets of assignments. Just as with C arrays, <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>vector</span></code>
subscripting does not perform automatic range checking, but class template <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></code> does provide this capability via member
function.</span></p>

<p style='text-align:justify'><em><span style='font-weight:normal;font-style:
normal'>Insertion at the back of a </span></em><code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman";
font-weight:normal'>vector</span></code><em><span style='font-weight:normal;
font-style:normal'> is efficient. The </span></em><code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman";
font-weight:normal'>vector</span></code><em><span style='font-weight:normal;
font-style:normal'> simply grows, if necessary, to accommodate the new item. It
is expensive to insert (or delete) an element in the middle of a </span></em><code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";font-weight:normal'>vector</span></code><em><span
style='font-weight:normal;font-style:normal'> — the entire portion of the </span></em><code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";font-weight:normal'>vector</span></code><em><span
style='font-weight:normal;font-style:normal'> after the insertion (or deletion)
point must be moved, because </span></em><code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman";
font-weight:normal'>vector</span></code><em><span style='font-weight:normal;
font-style:normal'> elements occupy contiguous cells in memory just as C or C++
“raw” arrays do. E</span></em><span style='font-weight:normal'>ach container
typically provides a variety of capabilities. Many of these capabilities are
common to several containers, but they are not always equally efficient for
each container. The programmer must choose the container most appropriate for
the application.</span></p>

<p style='text-align:justify'><em><span style='font-weight:normal;font-style:
normal'>Applications that require frequent insertions and deletions at both
ends of a container normally use a </span></em><code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman";
font-weight:normal'>deque</span></code><em><span style='font-weight:normal;
font-style:normal'> rather than a </span></em><code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman";
font-weight:normal'>vector</span></code><em><span style='font-weight:normal;
font-style:normal'>. Although we can insert and delete elements at the front
and back of both a </span></em><code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman";font-weight:normal'>vector</span></code><em><span
style='font-weight:normal;font-style:normal'> and a </span></em><code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";font-weight:normal'>deque</span></code><em><span
style='font-weight:normal;font-style:normal'>, class </span></em><code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";font-weight:normal'>deque</span></code><em><span
style='font-weight:normal;font-style:normal'> is more efficient than </span></em><code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";font-weight:normal'>vector</span></code><em><span
style='font-weight:normal;font-style:normal'> for doing insertions and
deletions at the front.<o:p></o:p></span></em></p>

<p style='text-align:justify'><em><span style='font-weight:normal;font-style:
normal'>Applications with frequent insertions and deletions in the middle
and/or at the extremes of a container normally use a </span></em><code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";font-weight:normal'>list</span></code><em><span
style='font-weight:normal;font-style:normal'>, due to its efficient
implementation of insertion and deletion anywhere in the data structure.<o:p></o:p></span></em></p>

<p style='text-align:justify'><span style='font-weight:normal'>The sequence
containers have several other common operations—</span><code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";font-weight:normal'>front</span></code><span
style='font-weight:normal'> to return a reference to the first element in the
container, </span><code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman";font-weight:normal'>back</span></code><span
style='font-weight:normal'> to return a reference to the last element in the
container, <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>push_back</span></code> to insert a new
element at the end of the container and <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>pop_back</span></code>
to remove the last element of the container.</span></p>

<h4 style='text-align:justify'><strong><span style='font-size:14.0pt;
color:black;font-weight:normal'>Vector Sequence Container</span></strong><span
style='font-size:14.0pt;color:black'><o:p></o:p></span></h4>

<p style='text-align:justify'><span style='font-weight:normal'>Class template <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></code> provides a data structure with
contiguous memory locations. This enables efficient, direct access to any
element of a vector via the subscript operator <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>[]</span></code>,
exactly as with a C or C++ “raw” array. Class template <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></code> is most commonly used when the data in
the container must be sorted and easily accessible via a subscript. When a <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></code>’s memory is exhausted, the <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></code> allocates a larger contiguous area of
memory, copies the original elements into the new memory and deallocates the
old memory.</span></p>

<p style='text-align:justify'><em><span style='font-weight:normal;font-style:
normal'>Objects of class template </span></em><code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman";
font-weight:normal'>vector</span></code><em><span style='font-weight:normal;
font-style:normal'> provide rapid indexed access with the overloaded subscript
operator </span></em><code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman";font-weight:normal'>[]</span></code><em><span
style='font-weight:normal;font-style:normal'> because they are stored in
contiguous memory like a C or C++ raw array.<o:p></o:p></span></em></p>

<p style='text-align:justify'><em><span style='font-weight:normal;font-style:
normal'>It is faster to insert many elements at once than one at a time.<o:p></o:p></span></em></p>

<p style='text-align:justify'><span style='font-weight:normal'>An important
part of every container is the type of iterator it supports. This determines
which algorithms can be applied to the container. A <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></code> supports random-access iterators. All
STL algorithms can operate on a <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>vector</span></code>.
The iterators for a <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>vector</span></code> are normally
implemented as pointers to elements of the <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>vector</span></code>.
Each STL algorithm that takes iterator arguments requires those iterators to
provide a minimum level of functionality. If an algorithm requires a forward
iterator, for example, that algorithm can operate on any container that
provides forward iterators, bidirectional iterators or random-access iterators.
As long as the container supports the algorithm’s minimum iterator
functionality, the algorithm can operate on the container. </span></p>

<h4 style='text-align:justify'><code><span style='font-size:14.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";color:black;font-weight:normal'>List</span></code><strong><span
style='font-size:14.0pt;color:black;font-weight:normal'> Sequence Container</span></strong><span
style='font-size:14.0pt;color:black;font-weight:normal'><o:p></o:p></span></h4>

<p style='text-align:justify'><span style='font-weight:normal'>The <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>list</span></code> sequence container provides an efficient
implementation for insertion and deletion operations at any location in the
container. If most of the insertions and deletions occur at the ends of the
container, the <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>deque</span></code> data structure
provides a more efficient implementation. Class template <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>list</span></code> is implemented as a doubly linked
list—every node in the <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>list</span></code> contains a pointer
to the previous node in the <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>list</span></code>
and to the next node in the <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>list</span></code>.
This enables class template <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>list</span></code> to
support bidirectional iterators that allow the container to be traversed both
forward and backward. Any algorithm that requires input, output, forward or
bidirectional iterators can operate on a <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>list</span></code>.
Many of the <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>list</span></code> member functions
manipulate the elements of the container as an ordered set of elements.</span></p>

<p style='text-align:justify'><span style='font-weight:normal'>In addition to
the member functions of all STL containers and the common member functions of
all sequence containers, class template <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>list</span></code>
provides nine other member functions—<code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>splice</span></code>,
<code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>push_front</span></code>, <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>pop_front</span></code>, <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>remove</span></code>,
<code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>remove_if</span></code>, <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>unique</span></code>, <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>merge</span></code>,
<code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>reverse</span></code> and <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>sort</span></code>. Several of these member functions are <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>list</span></code>-optimized implementations of STL
algorithms. Header file </span><code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman";font-weight:normal'>&lt;list&gt;</span></code><span
style='font-weight:normal'> must be included to use class <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>list</span></code>.</span></p>

<h4 style='text-align:justify'><code><span style='font-size:14.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";color:black;font-weight:normal'>Deque</span></code><strong><span
style='font-size:14.0pt;color:black;font-weight:normal'> Sequence Container</span></strong><span
style='font-size:14.0pt;color:black;font-weight:normal'><o:p></o:p></span></h4>

<p style='text-align:justify'><span style='font-weight:normal'>Class <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>deque</span></code> provides many of the benefits of a <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></code> and a <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>list</span></code>
in one container. The term <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>deque</span></code>
is short for “double-ended queue.” Class <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>deque</span></code>
is implemented to provide efficient indexed access (using subscripting) for
reading and modifying its elements, much like a <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>vector</span></code>.
Class <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>deque</span></code> is also implemented
for efficient insertion and deletion operations at its front and back, much
like a <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>list</span></code> (although a <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>list</span></code> is also capable of efficient insertions
and deletions in the middle of the <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>list</span></code>).
Class <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>deque</span></code> provides support
for random-access iterators, so <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>deques</span></code>
can be used with all STL algorithms. One of the most common uses of a <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>deque</span></code> is to maintain a first-in, first-out
queue of elements. In fact, a <code><span style='mso-ansi-font-size:12.0pt;
mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman";mso-bidi-font-family:"Times New Roman"'>deque</span></code>
is the default underlying implementation for the <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>queue</span></code>
adaptor.</span></p>

<p style='text-align:justify'><span style='font-weight:normal'>Additional
storage for a <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>deque</span></code> can be allocated at
either end of the <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>deque</span></code> in blocks of memory
that are typically maintained as an array of pointers to those blocks. Due to
the noncontiguous memory layout of a <code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman"'>deque</span></code>,
a <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>deque</span></code> iterator must be
more intelligent than the pointers that are used to iterate through <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>vector</span></code>s or pointer-based arrays.</span></p>

<p style='text-align:justify'><em><span style='font-weight:normal;font-style:
normal'>Insertions and deletions in the middle of a </span></em><code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";font-weight:normal;mso-bidi-font-style:italic'>deque</span></code><em><span
style='font-weight:normal;font-style:normal'> are optimized to minimize the
number of elements copied, so it is more efficient than a </span></em><code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";font-weight:normal;mso-bidi-font-style:italic'>vector</span></code><em><span
style='font-weight:normal;font-style:normal'> but less efficient than a </span></em><code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman";font-weight:normal;mso-bidi-font-style:italic'>list</span></code><em><span
style='font-weight:normal;font-style:normal'> for this kind of modification.</span></em><span
class=MsoHyperlink><span style='color:black;font-weight:normal;text-decoration:
none;text-underline:none'> </span></span><em><span style='font-weight:normal;
font-style:normal'>In general, </span></em><code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman";
font-weight:normal;mso-bidi-font-style:italic'>deque</span></code><em><span
style='font-weight:normal;font-style:normal'> has slightly higher overhead than
</span></em><code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman";font-weight:normal;mso-bidi-font-style:
italic'>vector.</span></code><em><span style='font-weight:normal;font-style:
normal'><o:p></o:p></span></em></p>

<p style='text-align:justify'><span style='font-weight:normal'>Class <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>deque</span></code> provides the same basic operations as
class <code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;
mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman"'>vector</span></code>, but adds member
functions </span><code><span style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:
12.0pt;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman";font-weight:normal'>push_front</span></code><span
style='font-weight:normal'> and </span><code><span style='mso-ansi-font-size:
12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman";
font-weight:normal'>pop_front</span></code><span style='font-weight:normal'> to
allow insertion and deletion at the beginning of the <code><span
style='mso-ansi-font-size:12.0pt;mso-bidi-font-size:12.0pt;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman";mso-bidi-font-family:
"Times New Roman"'>deque</span></code>, respectively.</span></p>

<p style='text-align:justify'><span style='font-weight:normal'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p><span style='font-weight:normal'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal><span style='font-weight:normal'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

</h3>

</div>

</body>

</html>
